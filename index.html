<!DOCTYPE html>
<html lang="en">
	<head>
		<title>Dinklets</title>
		<meta charset="utf-g">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link rel="preconnect" href="https://fonts.googleapis.com">
		<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
		<link href="https://fonts.googleapis.com/css2?family=Pirata+One&display=swap" rel="stylesheet">
		<style>
			html, body {
				height: 100%;
				margin: 0;
			}
			body {
				background-color: #fff;
				color: #333;
				overflow: hidden; /* Prevent scrollbars */
			}
			#c {
				width: 100%;
				height: 100%;
				display: block; /* Remove default spacing */
			}
            .game-ui {
                position: absolute;
                bottom: 5%;
                left: 50%;
                transform: translateX(-50%);
                text-align: center;
                color: #333;
                font-family: 'Pirata One', cursive;
            }
            .game-ui h2 {
                font-size: 2em;
                margin-bottom: 15px;
                font-weight: normal;
            }
            .game-ui button {
                font-family: 'Pirata One', cursive;
                font-size: 2em;
                padding: 10px 20px;
                margin: 0 10px;
                cursor: pointer;
                border: 2px solid #555;
                background-color: #f0f0f0;
                transition: background-color 0.3s, transform 0.1s;
                font-weight: normal;
                color: #333; /* Keep button text black for readability */
            }
            .game-ui button:hover {
                background-color: #ddd;
            }
            .game-ui button:active {
                transform: scale(0.95);
            }
            #game-title {
                position: absolute;
                top: 20px;
                left: 50%;
                transform: translateX(-50%);
                font-family: 'Pirata One', cursive;
                font-size: 3em;
                z-index: 10;
            }
            #game-title a {
                color: blue;
                text-decoration: underline;
            }
            #order-prompt {
                position: absolute;
                left: 100%;
                top: 50%;
                transform: translateY(-50%);
                margin-left: 15px;
                font-size: 0.4em;
                color: blue;
                display: flex;
                align-items: center;
                white-space: nowrap;
                line-height: 1;
            }
            #order-prompt .arrow {
                font-size: 1.5em;
                margin-right: 5px;
            }
            .instruction-ui {
                position: absolute;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                color: black;
                font-family: 'Pirata One', cursive;
                font-size: 1.2em;
                font-weight: normal;
                z-index: 10;
                text-align: center;
            }
            .port-label {
                position: absolute;
                color: black;
                font-family: 'Pirata One', cursive;
                font-size: 1.2em;
                font-weight: normal;
                z-index: 5;
                pointer-events: none;
                transform: translate(-50%, -50%);
            }
            #tally-board {
                position: absolute;
                top: 20px;
                right: 20px;
                font-family: 'Pirata One', cursive;
                font-size: 1.5em;
                color: #333;
                z-index: 10;
            }
            #rematch-ui {
                position: absolute;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                z-index: 20;
            }
		</style>
	</head>
	<body>
        <div id="game-title">
            <a href="https://www.etsy.com/uk/listing/4373477789/dinklets-2-player-luxury-travel-board" target="_blank">Dinklets</a>
            <div id="order-prompt">
                <span class="arrow">&larr;</span><div>order<br>here</div>
            </div>
        </div>
		<canvas id="c"></canvas>
        <audio id="victory-song" src="https://github.com/thegoldenfloret/Dinklets/raw/main/assets/Where%20Be%20Thy%20Dinklets.mp3" preload="auto"></audio>

        <div id="game-start-ui" class="game-ui">
            <h2 id="start-prompt">Loading...</h2>
            <div>
                <button id="galleons-btn" disabled>Galleons</button>
                <button id="corsairs-btn" disabled>Corsairs</button>
            </div>
        </div>

        <div id="game-play-ui" class="game-ui" style="display: none;">
            <h2 id="game-prompt"></h2>
        </div>

        <div id="rematch-ui" class="game-ui" style="display: none;">
             <button id="rematch-btn">Rematch</button>
        </div>

        <div id="reinforcement-ui" class="game-ui" style="display: none;">
            <h2>Deploy new ship?</h2>
            <div>
                <button id="deploy-yes-btn">Yes</button>
                <button id="deploy-no-btn">No</button>
            </div>
        </div>
        
        <div id="instruction-text" class="instruction-ui" style="display: none;">Tides direct the ships.</div>
        <div id="instruction-text-2" class="instruction-ui" style="display: none;">Ships attack by moving above <br> or below an enemy ship.</div>

        <div id="tally-board" style="display: none;">
            <div>Player: <span id="player-score"></span></div>
            <div>Adella: <span id="ai-score"></span></div>
        </div>

        <div class="port-label" id="port-label-7" style="display: none;">Port</div>
        <div class="port-label" id="port-label-13" style="display: none;">Port</div>
        <div class="port-label" id="port-label-12" style="display: none;">Port</div>
        <div class="port-label" id="port-label-18" style="display: none;">Port</div>

		<!-- Import Map for Three.js modules -->
		<script type="importmap">
			{
				"imports": {
					"three": "https://cdn.jsdelivr.net/npm/three@0.168.0/build/three.module.js",
					"three/addons/": "https://cdn.jsdelivr.net/npm/three@0.168.0/examples/jsm/"
				}
			}
		</script>

		<!-- Main 3D Logic -->
		<script type="module">
			// Import necessary Three.js modules
			import * as THREE from 'three';
			import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
			import { STLLoader } from 'three/addons/loaders/STLLoader.js';

            // --- GAME DATA ---
            const portSquarePairs = { 7: 13, 13: 7, 12: 18, 18: 12 };
            const tidePositionsPx = {
                A: { x: 160, y: 300 }, B: { x: 570, y: 300 }, C: { x: 980, y: 300 },
                D: { x: 980, y: 590 }, E: { x: 980, y: 880 }, F: { x: 570, y: 870 },
                G: { x: 160, y: 880 }, H: { x: 160, y: 590 }
            };
            const tideSequence = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H'];
            const moveVectors = {
                A: { r: -1, c: -1 }, B: { r: -1, c: 0 }, C: { r: -1, c: 1 },
                D: { r: 0, c: 1 },   E: { r: 1, c: 1 },  F: { r: 1, c: 0 },
                G: { r: 1, c: -1 },  H: { r: 0, c: -1 }
            };
            const gridInfo = {
                topLeft: { x: 200, y: 350 }, bottomRight: { x: 930, y: 830 },
                cols: 6, rows: 4, cornerSquares: [1, 6, 19, 24]
            };
            const shallowSquares = [2, 3, 4, 5, 20, 21, 22, 23];
            
            // --- GAME STATE VARIABLES ---
            let gameState = 'INIT'; // INIT, TIDE_PLACEMENT, SHIP_PLACEMENT, PLAY, GAME_OVER
            let turnPhase = ''; // MOVE_TIDE, SELECT_SHIP, MOVE_SELECTED_SHIP
            let playerTeam = null;
            let aiTeam = null;
            let playerWins = 0;
            let aiWins = 0;
            let isFirstGame = true;
            let hasPlayedVictorySong = false;
            let isPlayerTurn = false;
            let pendingReinforcement = null;
            let selectedShip = null;

            let shipsToMoveThisTurn = [];
            let totalShipsToMoveThisTurn = 0;

            let tidePlacementShadows = [], shipPlacementShadows = [], tempShadowPool = [];
            let initialTides = [], initialCorsairs = [], initialGalleons = [];
            let allInitialTideModels = [], allInitialCorsairModels = [], allInitialGalleonModels = [];
            
            let placedTides = [], placedCorsairs = [], placedGalleons = [];
            let tidesOnBoard = {};
            let tidesPlacedCount = 0, shipsPlacedCount = 0;
            
            let silverMaterial;
            let boardImageWidth, boardImageHeight;

            let animations = []; // For managing piece movements

            // Variables for click vs. drag detection
            let isDragging = false;
            const dragThreshold = 5; // pixels
            let startMousePos = new THREE.Vector2();

			// Basic scene setup
			const canvas = document.querySelector('#c');
			const renderer = new THREE.WebGLRenderer({ antialias: true, canvas });
			const scene = new THREE.Scene();
			scene.background = new THREE.Color(0xffffff);

			// Camera, Controls, Raycaster
			const camera = new THREE.PerspectiveCamera(75, 2, 0.1, 5000);
			const raycaster = new THREE.Raycaster();
			const mouse = new THREE.Vector2();
			const controls = new OrbitControls(camera, renderer.domElement);
			controls.enableDamping = true;
			controls.mouseButtons = { LEFT: THREE.MOUSE.ROTATE, MIDDLE: THREE.MOUSE.DOLLY, RIGHT: null };

			// Lighting
			const ambientLight = new THREE.AmbientLight(0xffffff, 1.5);
			scene.add(ambientLight);
			const directionalLight = new THREE.DirectionalLight(0xffffff, 2.5);
			directionalLight.position.set(-1, 2, 4);
			scene.add(directionalLight);

            // --- UI ELEMENTS ---
            const startUI = document.getElementById('game-start-ui');
            const startPrompt = document.getElementById('start-prompt');
            const playUI = document.getElementById('game-play-ui');
            const rematchUI = document.getElementById('rematch-ui');
            const reinforcementUI = document.getElementById('reinforcement-ui');
            const instructionText = document.getElementById('instruction-text');
            const instructionText2 = document.getElementById('instruction-text-2');
            const gamePrompt = document.getElementById('game-prompt');
            const tallyBoard = document.getElementById('tally-board');
            const playerScoreEl = document.getElementById('player-score');
            const aiScoreEl = document.getElementById('ai-score');
            const victorySong = document.getElementById('victory-song');
            const portLabels = {
                7: document.getElementById('port-label-7'),
                13: document.getElementById('port-label-13'),
                12: document.getElementById('port-label-12'),
                18: document.getElementById('port-label-18')
            };
            const portLabelWorldPositions = {};

            document.getElementById('galleons-btn').addEventListener('click', () => { playerTeam = 'galleons'; aiTeam = 'corsairs'; startGame(); });
            document.getElementById('corsairs-btn').addEventListener('click', () => { playerTeam = 'corsairs'; aiTeam = 'galleons'; startGame(); });
            document.getElementById('deploy-yes-btn').addEventListener('click', handleReinforcementChoice(true));
            document.getElementById('deploy-no-btn').addEventListener('click', handleReinforcementChoice(false));
            document.getElementById('rematch-btn').addEventListener('click', rematch);
            
            // --- AI ACTIONS ---
            function aiPlaceTide() {
                const available = tidePlacementShadows.filter(s => s.visible);
                if (available.length > 0) placeTideAt(available[Math.floor(Math.random() * available.length)]);
            }

            function aiPlaceShip() {
                const available = shipPlacementShadows.filter(s => s.userData.isShallow && s.visible);
                if (available.length > 0) placeShipAt(available[Math.floor(Math.random() * available.length)]);
            }

            function aiMoveTide() {
                const aiShips = aiTeam === 'corsairs' ? placedCorsairs : placedGalleons;
                const playerShips = playerTeam === 'corsairs' ? placedCorsairs : placedGalleons;
                const availableTideMoves = [];
                placedTides.forEach(tide => {
                    const nextKey = tideSequence[(tideSequence.indexOf(tide.userData.locationKey) + 1) % 8];
                    const nextShadow = tidePlacementShadows.find(s => s.userData.key === nextKey);
                    if (nextShadow) availableTideMoves.push({ tide, shadow: nextShadow });
                });

                if (availableTideMoves.length === 0) {
                    initiateShipMovePhase();
                    return;
                }

                let scoredMoves = availableTideMoves.map(tideMove => {
                    let score = 0;
                    const simulatedTides = placedTides.map(t => (t === tideMove.tide) ? tideMove.shadow.userData.key : t.userData.locationKey);
                    aiShips.forEach(ship => {
                        if (ship.userData.sunk) return;
                        const moves = calculateShipMovesWithTides(ship, simulatedTides, playerShips);
                        if (moves.some(m => m.isAttack)) score += 100;
                        if (moves.some(m => !m.isDanger)) score += 10;
                        if (!moves.some(m => !m.isDanger)) score -= 50;
                    });
                    return { move: tideMove, score };
                }).sort((a, b) => b.score - a.score);

                const bestMoves = scoredMoves.filter(m => m.score === scoredMoves[0].score);
                const chosenMove = bestMoves[Math.floor(Math.random() * bestMoves.length)].move;
                moveTide(chosenMove.tide, chosenMove.shadow);
            }

            function aiMoveShip(shipToMove, validMoves) {
                const playerShips = playerTeam === 'corsairs' ? placedCorsairs : placedGalleons;
                const attackMoves = validMoves.filter(m => !m.isDanger && isAttackMove(m.key, playerShips));
                const safeMoves = validMoves.filter(m => !m.isDanger);
                const chosenMove = attackMoves.length > 0 ? attackMoves[Math.floor(Math.random() * attackMoves.length)] :
                                safeMoves.length > 0 ? safeMoves[Math.floor(Math.random() * safeMoves.length)] :
                                validMoves.length > 0 ? validMoves[Math.floor(Math.random() * validMoves.length)] : null;
                
                if (!chosenMove) {
                    shipsToMoveThisTurn.shift();
                    processNextShipMove();
                    return;
                }
                
                let targetShadow = shipPlacementShadows.find(s => s.userData.key === chosenMove.key);
                if (!targetShadow) {
                    const {x, y} = getWorldCoordsFromGridRowCol(chosenMove.row, chosenMove.col);
                    targetShadow = { position: new THREE.Vector3(x, y, 1), userData: chosenMove };
                } else {
                    targetShadow = { position: targetShadow.position.clone(), userData: chosenMove };
                }
                handleShipMove(shipToMove, targetShadow);
            }

			// --- BOARD AND PIECE SETUP ---
			const loader = new THREE.TextureLoader();
			loader.load( 'https://raw.githubusercontent.com/thegoldenfloret/Dinklets/main/assets/goldenfloret.png', (texture) => {
					boardImageWidth = texture.image.width;
                    boardImageHeight = texture.image.height;
					const boardPlane = new THREE.Mesh(new THREE.PlaneGeometry(boardImageWidth, boardImageHeight), new THREE.MeshStandardMaterial({ map: texture, side: THREE.DoubleSide }));
					scene.add(boardPlane);

                    setupTidePlacementMarkers(boardImageWidth, boardImageHeight);
                    setupShipPlacementMarkers(boardImageWidth, boardImageHeight);

                    for (const key in portLabels) {
                        const coords = getWorldCoordsFromGridKey(parseInt(key));
                        portLabelWorldPositions[key] = new THREE.Vector3(coords.x, coords.y + 15, 5);
                    }

					silverMaterial = new THREE.MeshStandardMaterial({ color: 0xC0C0C0, metalness: 0.9, roughness: 0.5 });

                    let modelsLoaded = 0;
                    const totalModelsToLoad = 3;

                    function checkAllModelsLoaded() {
                        modelsLoaded++;
                        if (modelsLoaded === totalModelsToLoad) {
                            startPrompt.textContent = 'Galleons or Corsairs?';
                            document.getElementById('galleons-btn').disabled = false;
                            document.getElementById('corsairs-btn').disabled = false;
                        }
                    }

					const stlLoader = new STLLoader();
					stlLoader.load('https://raw.githubusercontent.com/thegoldenfloret/Dinklets/main/assets/tide.stl', (g) => { 
                        [{ x: 250, y: 180 }, { x: 300, y: 180 }, { x: 350, y: 180 }].forEach(p => allInitialTideModels.push({ model: createGamePiece(g, p, boardImageWidth, boardImageHeight), initialPos: p})); 
                        checkAllModelsLoaded();
                    });
					stlLoader.load('https://raw.githubusercontent.com/thegoldenfloret/Dinklets/main/assets/corsair.stl', (g) => { 
                        [{ x: 450, y: 180 }, { x: 550, y: 180 }, { x: 650, y: 180 }].forEach(p => allInitialCorsairModels.push({ model: createGamePiece(g, p, boardImageWidth, boardImageHeight), initialPos: p})); 
                        checkAllModelsLoaded();
                    });
					stlLoader.load('https://raw.githubusercontent.com/thegoldenfloret/Dinklets/main/assets/galleon.stl', (g) => { 
                        [{ x: 450, y: 100 }, { x: 550, y: 100 }, { x: 650, y: 100 }].forEach(p => allInitialGalleonModels.push({ model: createGamePiece(g, p, boardImageWidth, boardImageHeight), initialPos: p})); 
                        checkAllModelsLoaded();
                    });
					
                    fitCameraToBoard(boardImageWidth, boardImageHeight);
				}
			);

            function createGamePiece(geometry, pos, imageWidth, imageHeight) {
                const mesh = new THREE.Mesh(geometry, silverMaterial);
                const worldX = pos.x - (imageWidth / 2);
                const worldY = -pos.y + (imageHeight / 2);
                mesh.position.set(worldX, worldY, 25);
                mesh.rotation.x = Math.PI / 2;
                mesh.scale.set(3, 3, 3);
                scene.add(mesh);
                return mesh;
            }

            function setupTidePlacementMarkers(imageWidth, imageHeight) {
                const shadowGeo = new THREE.CircleGeometry(25, 32);
                const shadowMat = new THREE.MeshBasicMaterial({ color: 0x000000, transparent: true, opacity: 0.4 });
                for (const key in tidePositionsPx) {
                    const pos = tidePositionsPx[key];
                    const shadow = new THREE.Mesh(shadowGeo, shadowMat);
                    shadow.position.set(pos.x - imageWidth/2, -pos.y + imageHeight/2, 1);
                    shadow.visible = false;
                    shadow.userData = { type: 'tideShadow', key: key };
                    scene.add(shadow);
                    tidePlacementShadows.push(shadow);
                }
            }
            
            function setupShipPlacementMarkers(imageWidth, imageHeight) {
                const gridW = gridInfo.bottomRight.x - gridInfo.topLeft.x, gridH = gridInfo.bottomRight.y - gridInfo.topLeft.y;
                const cellW = gridW / gridInfo.cols, cellH = gridH / gridInfo.rows;
                const shadowGeo = new THREE.PlaneGeometry(cellW * 0.8, cellH * 0.8);
                const shadowMat = new THREE.MeshBasicMaterial({ color: 0x000000, transparent: true, opacity: 0.4 });
                for (let i = 1; i <= gridInfo.rows * gridInfo.cols; i++) {
                    const isShallow = shallowSquares.includes(i);
                    const {x, y} = getWorldCoordsFromGridKey(i);
                    const shadow = new THREE.Mesh(shadowGeo, shadowMat);
                    shadow.position.set(x, y, 1);
                    shadow.visible = false;
                    shadow.userData = { type: 'shipShadow', key: i, isShallow: isShallow };
                    scene.add(shadow);
                    shipPlacementShadows.push(shadow);
                }
                for (let i = 0; i < 8; i++) {
                    const shadow = new THREE.Mesh(shadowGeo, shadowMat);
                    shadow.visible = false;
                    scene.add(shadow);
                    tempShadowPool.push(shadow);
                }
            }

            function animateMove(object, targetPosition, onComplete) {
                animations.push({ object, startPosition: object.position.clone(), targetPosition, alpha: 0, duration: 0.5, onComplete });
            }

            // --- GAME ACTION FUNCTIONS ---
            function placeTideAt(shadow) {
                const tideToMove = initialTides.shift();
                if (!tideToMove) return; 
                const posKey = shadow.userData.key;
                const occupants = tidesOnBoard[posKey] ? tidesOnBoard[posKey].length : 0;
                const targetPosition = shadow.position.clone().add(new THREE.Vector3(occupants * 30, 0, 0)).setZ(25);

                animateMove(tideToMove, targetPosition, () => {
                    tideToMove.userData.locationKey = posKey;
                    if (tidesOnBoard[posKey]) { tidesOnBoard[posKey].push(tideToMove); } else { tidesOnBoard[posKey] = [tideToMove]; }
                    placedTides.push(tideToMove);
                    tidesPlacedCount++;
                    advanceTurn();
                });
            }

            function placeShipAt(shadow) {
                const shipType = shipsPlacedCount % 2 === 0 ? (playerTeam === 'corsairs' ? playerTeam : aiTeam) : (playerTeam === 'galleons' ? playerTeam : aiTeam);
                const shipToMove = (shipType === 'corsairs') ? initialCorsairs.shift() : initialGalleons.shift();
                if (shipToMove) {
                    const targetPosition = shadow.position.clone().setZ(25);
                    animateMove(shipToMove, targetPosition, () => {
                        Object.assign(shipToMove.userData, { locationKey: shadow.userData.key, lives: 2, justDeployed: false, sunk: false });
                        if(shipType === 'corsairs') placedCorsairs.push(shipToMove); else placedGalleons.push(shipToMove);
                        shadow.visible = false;
                        shipsPlacedCount++;
                        advanceTurn();
                    });
                }
            }

            function moveTide(tideToMove, targetShadow) {
                const newLocKey = targetShadow.userData.key;
                const oldLocKey = tideToMove.userData.locationKey;
                if (tidesOnBoard[oldLocKey]) tidesOnBoard[oldLocKey] = tidesOnBoard[oldLocKey].filter(t => t !== tideToMove);
                const occupants = tidesOnBoard[newLocKey] ? tidesOnBoard[newLocKey].length : 0;
                const targetPosition = targetShadow.position.clone().add(new THREE.Vector3(occupants * 30, 0, 0)).setZ(25);

                animateMove(tideToMove, targetPosition, () => {
                    if (!tidesOnBoard[newLocKey]) tidesOnBoard[newLocKey] = [];
                    tidesOnBoard[newLocKey].push(tideToMove);
                    tideToMove.userData.locationKey = newLocKey;
                    tidePlacementShadows.forEach(s => { s.visible = false; delete s.userData.tideToMove; });
                    initiateShipMovePhase();
                });
            }
            
            function damageShip(ship) {
                if (ship.userData.sunk) return;
                ship.userData.lives--;
                if (ship.userData.lives <= 0) {
                    Object.assign(ship.rotation, { x: Math.PI, z: 0 });
                    ship.position.z = 10;
                    ship.userData.sunk = true;
                    checkWinCondition();
                } else {
                    ship.rotation.z += THREE.MathUtils.degToRad(50);
                }
            }

            function checkForAdjacentAttacks(attackingShip) {
                if (gameState === 'GAME_OVER') return;
                const isCorsair = placedCorsairs.includes(attackingShip);
                const enemyShips = isCorsair ? placedGalleons : placedCorsairs;
                const { locationKey } = attackingShip.userData;
                enemyShips.forEach(enemy => {
                    if (!enemy.userData.sunk && (enemy.userData.locationKey === locationKey - gridInfo.cols || enemy.userData.locationKey === locationKey + gridInfo.cols)) {
                        damageShip(enemy);
                    }
                });
            }
            
            function deployReinforcement(info) {
                const { newShip, targetShadow, isCorsair, onComplete } = info;
                newShip.position.copy(targetShadow.position.clone().setZ(25)); 
                try {
                    Object.assign(newShip.userData, { locationKey: targetShadow.userData.key, lives: 2, justDeployed: true, sunk: false });
                    if (isCorsair) placedCorsairs.push(newShip); else placedGalleons.push(newShip);
                } finally { onComplete(); }
            }

            function handleReinforcementChoice(didDeploy) {
                return () => {
                    reinforcementUI.style.display = 'none';
                    playUI.style.display = 'block';
                    if (didDeploy && pendingReinforcement) {
                        deployReinforcement(pendingReinforcement);
                    } else if (pendingReinforcement) {
                        const sparePool = pendingReinforcement.isCorsair ? initialCorsairs : initialGalleons;
                        sparePool.unshift(pendingReinforcement.newShip); 
                        pendingReinforcement.onComplete();
                    }
                    pendingReinforcement = null;
                };
            }

            function checkForReinforcements(movedShip, onComplete) {
                if (gameState === 'GAME_OVER') { onComplete(); return; }
                const targetKey = portSquarePairs[movedShip.userData.locationKey];
                const isCorsair = placedCorsairs.includes(movedShip);
                const spareShips = isCorsair ? initialCorsairs : initialGalleons;
                const isTargetOccupied = [...placedCorsairs, ...placedGalleons].some(s => s.userData.locationKey === targetKey);

                if (targetKey && spareShips.length > 0 && !isTargetOccupied) {
                    const targetShadow = shipPlacementShadows.find(s => s.userData.key === targetKey);
                    if(targetShadow){
                        const reinforcementInfo = { newShip: spareShips.shift(), targetShadow, isCorsair, onComplete };
                        if (isPlayerTurn) {
                            pendingReinforcement = reinforcementInfo;
                            playUI.style.display = 'none';
                            reinforcementUI.style.display = 'block';
                        } else {
                            deployReinforcement(reinforcementInfo);
                        }
                        return;
                    }
                }
                onComplete();
            }

            function handleShipMove(shipToMove, targetShadow) {
                if (targetShadow.userData.isDanger) {
                    damageShip(shipToMove);
                    if (gameState === 'GAME_OVER') return;
                    shipPlacementShadows.forEach(s => s.visible = false);
                    tempShadowPool.forEach(s => s.visible = false);
                    shipsToMoveThisTurn = shipsToMoveThisTurn.filter(s => s !== shipToMove);
                    selectedShip = null;
                    processNextShipMove();
                } else {
                    const targetPosition = targetShadow.position.clone().setZ(25);
                    animateMove(shipToMove, targetPosition, () => {
                        shipToMove.userData.locationKey = targetShadow.userData.key;
                        shipPlacementShadows.forEach(s => s.visible = false);
                        tempShadowPool.forEach(s => s.visible = false);
                        checkForAdjacentAttacks(shipToMove);
                        if (gameState === 'GAME_OVER') return;
                        shipsToMoveThisTurn = shipsToMoveThisTurn.filter(s => s !== shipToMove);
                        selectedShip = null;
                        checkForReinforcements(shipToMove, processNextShipMove);
                    });
                }
            }
			
            function onMouseDown(event) {
                isDragging = false;
                startMousePos.set(event.clientX, event.clientY);
            }
            function onMouseMove(event) {
                if (startMousePos.distanceTo(new THREE.Vector2(event.clientX, event.clientY)) > dragThreshold) isDragging = true;
            }
            function onMouseUp(event) {
                if (isDragging) return;
                if (!isPlayerTurn || animations.length > 0 || pendingReinforcement || gameState === 'GAME_OVER') return;
                mouse.set((event.clientX / window.innerWidth) * 2 - 1, -(event.clientY / window.innerHeight) * 2 + 1);
                raycaster.setFromCamera(mouse, camera);
                
                const getIntersect = (objects) => {
                    const intersects = raycaster.intersectObjects(objects);
                    return (intersects.length > 0 && intersects[0].object.visible) ? intersects[0].object : null;
                };

                if (gameState === 'TIDE_PLACEMENT') {
                    const shadow = getIntersect(tidePlacementShadows);
                    if (shadow) placeTideAt(shadow);
                } else if (gameState === 'SHIP_PLACEMENT') {
                    const shadow = getIntersect(shipPlacementShadows);
                    if (shadow) placeShipAt(shadow);
                } else if (gameState === 'PLAY') {
                    if (turnPhase === 'MOVE_TIDE') {
                        const shadow = getIntersect(tidePlacementShadows);
                        if (shadow) moveTide(shadow.userData.tideToMove, shadow);
                    } else if (turnPhase === 'SELECT_SHIP') {
                        const intersects = raycaster.intersectObjects(shipsToMoveThisTurn);
                        if (intersects.length > 0) showMovesForShip(intersects[0].object);
                    } else if (turnPhase === 'MOVE_SELECTED_SHIP') {
                        const shadow = getIntersect([...shipPlacementShadows, ...tempShadowPool]);
                        if (shadow && selectedShip) handleShipMove(selectedShip, shadow);
                    }
                }
            }

            // --- HELPER & STATE FUNCTIONS ---
            function getWorldCoordsFromGridKey(key) {
                const col = (key - 1) % gridInfo.cols;
                const row = Math.floor((key - 1) / gridInfo.cols);
                return getWorldCoordsFromGridRowCol(row, col);
            }
            function getWorldCoordsFromGridRowCol(row, col) {
                const gridW = gridInfo.bottomRight.x - gridInfo.topLeft.x, gridH = gridInfo.bottomRight.y - gridInfo.topLeft.y;
                const cellW = gridW / gridInfo.cols, cellH = gridH / gridInfo.rows;
                const px = gridInfo.topLeft.x + col * cellW + cellW / 2, py = gridInfo.topLeft.y + row * cellH + cellH / 2;
                return { x: px - boardImageWidth / 2, y: -py + boardImageHeight / 2 };
            }
            function isAttackMove(moveKey, enemyShips) {
                const keyAbove = moveKey - gridInfo.cols, keyBelow = moveKey + gridInfo.cols;
                return enemyShips.some(e => !e.userData.sunk && (e.userData.locationKey === keyAbove || e.userData.locationKey === keyBelow));
            }
            function calculateShipMovesWithTides(ship, tideLocations, enemyShips) {
                const currentSquare = ship.userData.locationKey;
                const currentCol = (currentSquare - 1) % gridInfo.cols, currentRow = Math.floor((currentSquare - 1) / gridInfo.cols);
                const allShips = [...placedCorsairs, ...placedGalleons];
                const occupiedSquares = allShips.map(s => s.userData.locationKey);
                let moveDestinations = new Map();
                
                tideLocations.forEach(locKey => {
                    const vec = moveVectors[locKey];
                    const newRow = currentRow + vec.r, newCol = currentCol + vec.c;
                    const newSquare = newRow * gridInfo.cols + newCol + 1;
                    
                    if (!moveDestinations.has(newSquare)) {
                        const isOffGrid = newRow < 0 || newRow >= gridInfo.rows || newCol < 0 || newCol >= gridInfo.cols;
                        const isCorner = !isOffGrid && gridInfo.cornerSquares.includes(newSquare);
                        const isOccupied = !isOffGrid && occupiedSquares.includes(newSquare);
                        moveDestinations.set(newSquare, {
                            key: newSquare, row: newRow, col: newCol,
                            isDanger: isOffGrid || isCorner || isOccupied,
                            isOnGrid: !isOffGrid,
                            isAttack: !isOffGrid && !isOccupied && enemyShips && isAttackMove(newSquare, enemyShips)
                        });
                    }
                });
                return Array.from(moveDestinations.values());
            }
            function calculateShipMoves(ship) {
                const enemyShips = placedCorsairs.includes(ship) ? placedGalleons : placedCorsairs;
                const tideLocations = placedTides.map(t => t.userData.locationKey);
                return calculateShipMovesWithTides(ship, tideLocations, enemyShips);
            }

            // --- GAME FLOW CONTROL ---
            function checkWinCondition() {
                const playerShips = (playerTeam === 'corsairs' ? placedCorsairs : placedGalleons);
                const aiShips = (aiTeam === 'corsairs' ? placedCorsairs : placedGalleons);
                const allPlayerShipsSunk = playerShips.length > 0 && playerShips.every(s => s.userData.sunk);
                const allAiShipsSunk = aiShips.length > 0 && aiShips.every(s => s.userData.sunk);

                if (allPlayerShipsSunk) {
                    gameState = 'GAME_OVER';
                    gamePrompt.textContent = 'Adella wins!';
                    aiWins++;
                    updateTallyBoard();
                    rematchUI.style.display = 'block';
                    return true;
                }
                if (allAiShipsSunk) {
                    gameState = 'GAME_OVER';
                    gamePrompt.textContent = "You've won!";
                    playerWins++;
                    if (!hasPlayedVictorySong) {
                        victorySong.play();
                        hasPlayedVictorySong = true;
                    }
                    updateTallyBoard();
                    rematchUI.style.display = 'block';
                    return true;
                }
                return false;
            }

            function updateTallyBoard(){
                tallyBoard.style.display = 'block';
                playerScoreEl.textContent = 'I'.repeat(playerWins);
                aiScoreEl.textContent = 'I'.repeat(aiWins);
            }
            
            function startGame() {
                startUI.style.display = 'none';
                playUI.style.display = 'block';
                if (isFirstGame) {
                    instructionText.style.display = 'block';
                }
                initialTides = allInitialTideModels.map(m => m.model);
                initialCorsairs = allInitialCorsairModels.map(m => m.model);
                initialGalleons = allInitialGalleonModels.map(m => m.model);
                startNewRound();
            }

            function rematch(){
                isFirstGame = false;
                rematchUI.style.display = 'none';
                gamePrompt.textContent = '';
                
                allInitialTideModels.forEach(t => t.model.position.set(t.initialPos.x - boardImageWidth/2, -t.initialPos.y + boardImageHeight/2, 25));
                allInitialCorsairModels.forEach(c => {
                    c.model.position.set(c.initialPos.x - boardImageWidth/2, -c.initialPos.y + boardImageHeight/2, 25);
                    Object.assign(c.model.rotation, {x: Math.PI / 2, z: 0});
                });
                allInitialGalleonModels.forEach(g => {
                    g.model.position.set(g.initialPos.x - boardImageWidth/2, -g.initialPos.y + boardImageHeight/2, 25);
                    Object.assign(g.model.rotation, {x: Math.PI / 2, z: 0});
                });
                
                initialTides = allInitialTideModels.map(m => m.model);
                initialCorsairs = allInitialCorsairModels.map(m => m.model);
                initialGalleons = allInitialGalleonModels.map(m => m.model);
                placedTides = []; placedCorsairs = []; placedGalleons = [];
                tidesOnBoard = {}; tidesPlacedCount = 0; shipsPlacedCount = 0;
                
                [playerTeam, aiTeam] = [aiTeam, playerTeam];
                
                startNewRound();
            }

            function startNewRound() {
                gameState = 'TIDE_PLACEMENT';
                if (isFirstGame) {
                    instructionText.style.display = 'block';
                }
                if (playerTeam === 'galleons') {
                    isPlayerTurn = true;
                    gamePrompt.textContent = 'Select a shadow to place a tide.';
                    tidePlacementShadows.forEach(s => s.visible = true);
                } else {
                    isPlayerTurn = false;
                    gamePrompt.textContent = 'Adella is thinking...';
                    tidePlacementShadows.forEach(s => s.visible = true);
                    setTimeout(aiPlaceTide, 1500);
                }
            }

            function initiateTideMovePhase() {
                if (gameState === 'GAME_OVER') return;
                turnPhase = 'MOVE_TIDE';
                placedTides.forEach(tide => {
                    const nextKey = tideSequence[(tideSequence.indexOf(tide.userData.locationKey) + 1) % 8];
                    const nextShadow = tidePlacementShadows.find(s => s.userData.key === nextKey);
                    if (nextShadow) {
                        nextShadow.visible = true;
                        nextShadow.userData.tideToMove = tide;
                    }
                });
                if (isPlayerTurn) {
                    gamePrompt.textContent = 'Select a shadow to move a tide.';
                } else {
                    gamePrompt.textContent = 'Adella is thinking...';
                    setTimeout(aiMoveTide, 1500);
                }
            }

            function showMovesForShip(ship) {
                selectedShip = ship;
                shipPlacementShadows.forEach(s => s.visible = false);
                tempShadowPool.forEach(s => s.visible = false);

                const moves = calculateShipMoves(ship);
                if (moves.length === 0) {
                    setTimeout(() => {
                        shipsToMoveThisTurn = shipsToMoveThisTurn.filter(s => s !== ship);
                        processNextShipMove();
                    }, 1500);
                    return;
                }
                
                turnPhase = 'MOVE_SELECTED_SHIP';
                gamePrompt.textContent = 'Select a shadow.';

                let tempShadowIdx = 0;
                moves.forEach(move => {
                    let shadow = move.isOnGrid ? shipPlacementShadows.find(s => s.userData.key === move.key) : tempShadowPool[tempShadowIdx++];
                    if (shadow) {
                        if(!move.isOnGrid){
                            const { x, y } = getWorldCoordsFromGridRowCol(move.row, move.col);
                            shadow.position.set(x, y, 1);
                        }
                        shadow.visible = true;
                        shadow.userData = { ...shadow.userData, ...move };
                    }
                });
            }

            function processNextShipMove() {
                if (gameState === 'GAME_OVER') return;

                shipPlacementShadows.forEach(s => s.visible = false);
                tempShadowPool.forEach(s => s.visible = false);
                selectedShip = null;

                if (shipsToMoveThisTurn.length === 0) {
                    advanceTurn();
                    return;
                }

                if (isPlayerTurn) {
                    if (shipsToMoveThisTurn.length > 1) {
                        turnPhase = 'SELECT_SHIP';
                        gamePrompt.textContent = 'Select a ship, then a shadow.';
                    } else {
                        showMovesForShip(shipsToMoveThisTurn[0]);
                    }
                } else {
                    const shipToMove = shipsToMoveThisTurn[0];
                    const moves = calculateShipMoves(shipToMove);
                    const movedCount = totalShipsToMoveThisTurn - shipsToMoveThisTurn.length;
                    gamePrompt.textContent = `Adella is moving her ship (${movedCount + 1} of ${totalShipsToMoveThisTurn})`;
                    setTimeout(() => aiMoveShip(shipToMove, moves), 1500);
                }
            }

            function initiateShipMovePhase() {
                if (gameState === 'GAME_OVER') return;

                const playerShips = isPlayerTurn ? (playerTeam === 'corsairs' ? placedCorsairs : placedGalleons) : (aiTeam === 'corsairs' ? placedCorsairs : placedGalleons);
                shipsToMoveThisTurn = playerShips.filter(ship => !ship.userData.sunk && !ship.userData.justDeployed);
                totalShipsToMoveThisTurn = shipsToMoveThisTurn.length;
                
                if (shipsToMoveThisTurn.length === 0) {
                    setTimeout(advanceTurn, 1500);
                    return;
                }
                processNextShipMove();
            }

            function advanceTurn() {
                if (gameState === 'GAME_OVER') return;

                if (gameState === 'TIDE_PLACEMENT') {
                    isPlayerTurn = !isPlayerTurn;
                    if (tidesPlacedCount < 3) {
                        gamePrompt.textContent = isPlayerTurn ? `Place ${tidesPlacedCount === 1 ? 'second' : 'third'} tide.` : 'Adella is thinking...';
                        if (!isPlayerTurn) setTimeout(aiPlaceTide, 1500);
                    } else { 
                        if (isFirstGame) {
                            instructionText.style.display = 'none';
                            instructionText2.style.display = 'block';
                            Object.values(portLabels).forEach(l => l.style.display = 'block');
                        }
                        gameState = 'SHIP_PLACEMENT';
                        tidePlacementShadows.forEach(s => s.visible = false);
                        isPlayerTurn = playerTeam === 'corsairs'; 
                        gamePrompt.textContent = isPlayerTurn ? 'Set ship on a shallow.' : 'Adella is thinking...';
                        shipPlacementShadows.forEach(s => { if(s.userData.isShallow) s.visible = true; });
                        if (!isPlayerTurn) setTimeout(aiPlaceShip, 1500);
                    }
                } else if (gameState === 'SHIP_PLACEMENT') {
                     isPlayerTurn = !isPlayerTurn;
                    if (shipsPlacedCount < 2) {
                        gamePrompt.textContent = isPlayerTurn ? 'Set ship on a shallow.' : 'Adella is thinking...';
                        if (!isPlayerTurn) setTimeout(aiPlaceShip, 1500);
                    } else {
                        instructionText2.style.display = 'none';
                        Object.values(portLabels).forEach(l => l.style.display = 'none');
                        gameState = 'PLAY';
                        gamePrompt.textContent = 'Board is set.';
                        shipPlacementShadows.forEach(s => s.visible = false);
                        isPlayerTurn = playerTeam === 'corsairs';
                        setTimeout(initiateTideMovePhase, 1500);
                    }
                } else if (gameState === 'PLAY') {
                    isPlayerTurn = !isPlayerTurn;
                    const shipsToActivate = isPlayerTurn ? (playerTeam === 'corsairs' ? placedCorsairs : placedGalleons) : (aiTeam === 'corsairs' ? placedCorsairs : placedGalleons);
                    shipsToActivate.forEach(ship => ship.userData.justDeployed = false);
                    setTimeout(initiateTideMovePhase, 1000);
                }
            }

            function updatePortLabelPositions() {
                if (gameState !== 'SHIP_PLACEMENT') return;
                for (const key in portLabelWorldPositions) {
                    const worldPos = portLabelWorldPositions[key];
                    const screenPos = worldPos.clone().project(camera);
                    const x = (screenPos.x * .5 + .5) * renderer.domElement.clientWidth;
                    const y = (screenPos.y * -.5 + .5) * renderer.domElement.clientHeight;
                    portLabels[key].style.left = `${x}px`;
                    portLabels[key].style.top = `${y}px`;
                }
            }

            window.addEventListener('mousedown', onMouseDown);
            window.addEventListener('mousemove', onMouseMove);
            window.addEventListener('mouseup', onMouseUp);

            function fitCameraToBoard(imageWidth, imageHeight) {
                resizeRendererToDisplaySize(renderer);
                const boardAspect = imageWidth / imageHeight;
                const cameraAspect = camera.aspect;
                const vFOV = THREE.MathUtils.degToRad(camera.fov);
                let distance;
                if (boardAspect > cameraAspect) {
                    const hFOV = 2 * Math.atan(Math.tan(vFOV / 2) * cameraAspect);
                    distance = (imageWidth / 2) / Math.tan(hFOV / 2);
                } else {
                    distance = (imageHeight / 2) / Math.tan(vFOV / 2);
                }
                camera.position.z = distance * 1.05;
                controls.target.set(0, 0, 0);
                controls.update();
            }

			function resizeRendererToDisplaySize(renderer) {
				const canvas = renderer.domElement;
				const width = canvas.clientWidth, height = canvas.clientHeight;
				if (canvas.width !== width || canvas.height !== height) {
					renderer.setSize(width, height, false);
					camera.aspect = width / height;
					camera.updateProjectionMatrix();
				}
			}

			function animate() {
				requestAnimationFrame(animate);
                const delta = 0.016; // Assume ~60fps
                animations = animations.filter(anim => {
                    anim.alpha += delta / anim.duration;
                    if(anim.alpha >= 1) {
                        anim.object.position.copy(anim.targetPosition);
                        if(anim.onComplete) anim.onComplete();
                        return false; // Remove from list
                    }
                    anim.object.position.lerpVectors(anim.startPosition, anim.targetPosition, anim.alpha);
                    return true; // Keep in list
                });
                updatePortLabelPositions();
				resizeRendererToDisplaySize(renderer);
				controls.update();
				renderer.render(scene, camera);
			}
			animate();
		</script>
	</body>
</html>

