<!DOCTYPE html>
<html lang="en">
	<head>
		<title>3D Board Game</title>
		<meta charset="utf-g">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link rel="preconnect" href="https://fonts.googleapis.com">
		<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
		<link href="https://fonts.googleapis.com/css2?family=Pirata+One&display=swap" rel="stylesheet">
		<style>
			html, body {
				height: 100%;
				margin: 0;
			}
			body {
				background-color: #fff;
				color: #fff;
				overflow: hidden; /* Prevent scrollbars */
			}
			#c {
				width: 100%;
				height: 100%;
				display: block; /* Remove default spacing */
			}
            .game-ui {
                position: absolute;
                bottom: 5%;
                left: 50%;
                transform: translateX(-50%);
                text-align: center;
                color: #333;
                font-family: 'Pirata One', cursive;
            }
            .game-ui h2 {
                font-size: 2em;
                margin-bottom: 15px;
                font-weight: normal;
            }
            .game-ui button {
                font-family: 'Pirata One', cursive;
                font-size: 2em;
                padding: 10px 20px;
                margin: 0 10px;
                cursor: pointer;
                border: 2px solid #555;
                background-color: #f0f0f0;
                transition: background-color 0.3s, transform 0.1s;
                font-weight: normal;
            }
            .game-ui button:hover {
                background-color: #ddd;
            }
            .game-ui button:active {
                transform: scale(0.95);
            }
            #game-title {
                position: absolute;
                top: 20px;
                left: 50%;
                transform: translateX(-50%);
                font-family: 'Pirata One', cursive;
                font-size: 3em;
                z-index: 10;
            }
            #game-title a {
                color: blue;
                text-decoration: underline;
            }
            .instruction-ui {
                position: absolute;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                color: black;
                font-family: 'Pirata One', cursive;
                font-size: 1.2em; /* Match port label size */
                font-weight: normal;
                z-index: 10;
                text-align: center;
            }
            .port-label {
                position: absolute;
                color: black;
                font-family: 'Pirata One', cursive;
                font-size: 1.2em;
                font-weight: normal;
                z-index: 5;
                pointer-events: none; /* So they don't interfere with clicks */
                transform: translate(-50%, -50%); /* Center the label on the coordinate */
            }
		</style>
	</head>
	<body>
        <div id="game-title">
            <a href="https://www.etsy.com/uk/listing/4373477789/dinklets-2-player-luxury-travel-board" target="_blank">Dinklets</a>
        </div>
		<canvas id="c"></canvas>

        <div id="game-start-ui" class="game-ui">
            <h2>Galleons or Corsairs?</h2>
            <div>
                <button id="galleons-btn">Galleons</button>
                <button id="corsairs-btn">Corsairs</button>
            </div>
        </div>

        <div id="game-play-ui" class="game-ui" style="display: none;">
            <h2 id="game-prompt"></h2>
        </div>

        <div id="reinforcement-ui" class="game-ui" style="display: none;">
            <h2>Deploy new ship?</h2>
            <div>
                <button id="deploy-yes-btn">Yes</button>
                <button id="deploy-no-btn">No</button>
            </div>
        </div>
        
        <div id="instruction-text" class="instruction-ui" style="display: none;">Tides direct the ships.</div>
        <div id="instruction-text-2" class="instruction-ui" style="display: none;">Ships attack by moving above <br> or below an enemy ship.</div>

        <div class="port-label" id="port-label-7" style="display: none;">Port</div>
        <div class="port-label" id="port-label-13" style="display: none;">Port</div>
        <div class="port-label" id="port-label-12" style="display: none;">Port</div>
        <div class="port-label" id="port-label-18" style="display: none;">Port</div>

		<!-- Import Map for Three.js modules -->
		<script type="importmap">
			{
				"imports": {
					"three": "https://cdn.jsdelivr.net/npm/three@0.168.0/build/three.module.js",
					"three/addons/": "https://cdn.jsdelivr.net/npm/three@0.168.0/examples/jsm/"
				}
			}
		</script>

		<!-- Main 3D Logic -->
		<script type="module">
			// Import necessary Three.js modules
			import * as THREE from 'three';
			import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
			import { STLLoader } from 'three/addons/loaders/STLLoader.js';

            // --- GAME DATA ---
            const portSquarePairs = { 7: 13, 13: 7, 12: 18, 18: 12 };
            const tidePositionsPx = {
                A: { x: 160, y: 300 }, B: { x: 570, y: 300 }, C: { x: 980, y: 300 },
                D: { x: 980, y: 590 }, E: { x: 980, y: 880 }, F: { x: 570, y: 870 },
                G: { x: 160, y: 880 }, H: { x: 160, y: 590 }
            };
            const tideSequence = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H'];
            const moveVectors = {
                A: { r: -1, c: -1 }, B: { r: -1, c: 0 }, C: { r: -1, c: 1 },
                D: { r: 0, c: 1 },   E: { r: 1, c: 1 },  F: { r: 1, c: 0 },
                G: { r: 1, c: -1 },  H: { r: 0, c: -1 }
            };
            const gridInfo = {
                topLeft: { x: 200, y: 350 }, bottomRight: { x: 930, y: 830 },
                cols: 6, rows: 4, cornerSquares: [1, 6, 19, 24]
            };
            const shallowSquares = [2, 3, 4, 5, 20, 21, 22, 23];
            
            // --- GAME STATE VARIABLES ---
            let gameState = 'INIT'; // INIT, TIDE_PLACEMENT, SHIP_PLACEMENT, PLAY, GAME_OVER
            let turnPhase = ''; // MOVE_TIDE, SELECT_SHIP, MOVE_SELECTED_SHIP
            let playerTeam = null;
            let aiTeam = null;
            let isPlayerTurn = false;
            let pendingReinforcement = null;
            let selectedShip = null;

            let shipsToMoveThisTurn = [];
            let totalShipsToMoveThisTurn = 0;

            let tidePlacementShadows = [], shipPlacementShadows = [], tempShadowPool = [];
            let initialTides = [], initialCorsairs = [], initialGalleons = [];
            
            let placedTides = [], placedCorsairs = [], placedGalleons = [];
            let tidesOnBoard = {};
            let tidesPlacedCount = 0, shipsPlacedCount = 0;
            
            let silverMaterial;
            let boardImageWidth, boardImageHeight;

            let animations = []; // For managing piece movements

            // Variables for click vs. drag detection
            let isDragging = false;
            const dragThreshold = 5; // pixels
            let startMousePos = new THREE.Vector2();

			// Basic scene setup
			const canvas = document.querySelector('#c');
			const renderer = new THREE.WebGLRenderer({ antialias: true, canvas });
			const scene = new THREE.Scene();
			scene.background = new THREE.Color(0xffffff);

			// Camera, Controls, Raycaster
			const camera = new THREE.PerspectiveCamera(75, 2, 0.1, 5000);
			const raycaster = new THREE.Raycaster();
			const mouse = new THREE.Vector2();
			const controls = new OrbitControls(camera, renderer.domElement);
			controls.enableDamping = true;
			controls.mouseButtons = { LEFT: THREE.MOUSE.ROTATE, MIDDLE: THREE.MOUSE.DOLLY, RIGHT: null };

			// Lighting
			const ambientLight = new THREE.AmbientLight(0xffffff, 1.5);
			scene.add(ambientLight);
			const directionalLight = new THREE.DirectionalLight(0xffffff, 2.5);
			directionalLight.position.set(-1, 2, 4);
			scene.add(directionalLight);

            // --- UI ELEMENTS ---
            const startUI = document.getElementById('game-start-ui');
            const playUI = document.getElementById('game-play-ui');
            const reinforcementUI = document.getElementById('reinforcement-ui');
            const instructionText = document.getElementById('instruction-text');
            const instructionText2 = document.getElementById('instruction-text-2');
            const gamePrompt = document.getElementById('game-prompt');
            const portLabels = {
                7: document.getElementById('port-label-7'),
                13: document.getElementById('port-label-13'),
                12: document.getElementById('port-label-12'),
                18: document.getElementById('port-label-18')
            };
            const portLabelWorldPositions = {};

            document.getElementById('galleons-btn').addEventListener('click', () => { playerTeam = 'galleons'; aiTeam = 'corsairs'; startGame(); });
            document.getElementById('corsairs-btn').addEventListener('click', () => { playerTeam = 'corsairs'; aiTeam = 'galleons'; startGame(); });
            document.getElementById('deploy-yes-btn').addEventListener('click', handleReinforcementChoice(true));
            document.getElementById('deploy-no-btn').addEventListener('click', handleReinforcementChoice(false));


            function startGame() {
                startUI.style.display = 'none';
                playUI.style.display = 'block';
                instructionText.style.display = 'block';
                gameState = 'TIDE_PLACEMENT';
                if (playerTeam === 'galleons') {
                    isPlayerTurn = true;
                    gamePrompt.textContent = 'Select a shadow to place a tide.';
                    tidePlacementShadows.forEach(s => s.visible = true);
                } else {
                    isPlayerTurn = false;
                    gamePrompt.textContent = 'Adella is thinking...';
                    tidePlacementShadows.forEach(s => s.visible = true);
                    setTimeout(aiPlaceTide, 1500);
                }
            }


			// --- BOARD AND PIECE SETUP ---
			const loader = new THREE.TextureLoader();
			loader.load( 'https://raw.githubusercontent.com/thegoldenfloret/Dinklets/main/assets/goldenfloret.png', (texture) => {
					boardImageWidth = texture.image.width;
                    boardImageHeight = texture.image.height;
					const boardPlane = new THREE.Mesh(new THREE.PlaneGeometry(boardImageWidth, boardImageHeight), new THREE.MeshStandardMaterial({ map: texture, side: THREE.DoubleSide }));
					scene.add(boardPlane);

                    setupTidePlacementMarkers(boardImageWidth, boardImageHeight);
                    setupShipPlacementMarkers(boardImageWidth, boardImageHeight);

                    // Calculate world positions for port labels after board is set up
                    for (const key in portLabels) {
                        const coords = getWorldCoordsFromGridKey(parseInt(key));
                        portLabelWorldPositions[key] = new THREE.Vector3(coords.x, coords.y + 15, 5);
                    }

					silverMaterial = new THREE.MeshStandardMaterial({ color: 0xC0C0C0, metalness: 0.9, roughness: 0.5 });

					const stlLoader = new STLLoader();
					stlLoader.load('https://raw.githubusercontent.com/thegoldenfloret/Dinklets/main/assets/tide.stl', (g) => { [{ x: 250, y: 180 }, { x: 300, y: 180 }, { x: 350, y: 180 }].forEach(p => initialTides.push(createGamePiece(g, p, boardImageWidth, boardImageHeight))); });
					stlLoader.load('https://raw.githubusercontent.com/thegoldenfloret/Dinklets/main/assets/corsair.stl', (g) => { [{ x: 450, y: 180 }, { x: 550, y: 180 }, { x: 650, y: 180 }].forEach(p => initialCorsairs.push(createGamePiece(g, p, boardImageWidth, boardImageHeight))); });
					stlLoader.load('https://raw.githubusercontent.com/thegoldenfloret/Dinklets/main/assets/galleon.stl', (g) => { [{ x: 450, y: 100 }, { x: 550, y: 100 }, { x: 650, y: 100 }].forEach(p => initialGalleons.push(createGamePiece(g, p, boardImageWidth, boardImageHeight))); });
					fitCameraToBoard(boardImageWidth, boardImageHeight);
				}
			);

            function createGamePiece(geometry, pos, imageWidth, imageHeight) {
                const mesh = new THREE.Mesh(geometry, silverMaterial);
                const worldX = pos.x - (imageWidth / 2);
                const worldY = -pos.y + (imageHeight / 2);
                mesh.position.set(worldX, worldY, 25);
                mesh.rotation.x = Math.PI / 2;
                mesh.scale.set(3, 3, 3);
                scene.add(mesh);
                return mesh;
            }

            function setupTidePlacementMarkers(imageWidth, imageHeight) {
                const shadowGeo = new THREE.CircleGeometry(25, 32);
                const shadowMat = new THREE.MeshBasicMaterial({ color: 0x000000, transparent: true, opacity: 0.4 });
                for (const key in tidePositionsPx) {
                    const pos = tidePositionsPx[key];
                    const shadow = new THREE.Mesh(shadowGeo, shadowMat);
                    shadow.position.set(pos.x - imageWidth/2, -pos.y + imageHeight/2, 1);
                    shadow.visible = false;
                    shadow.userData = { type: 'tideShadow', key: key };
                    scene.add(shadow);
                    tidePlacementShadows.push(shadow);
                }
            }
            
            function setupShipPlacementMarkers(imageWidth, imageHeight) {
                const gridW = gridInfo.bottomRight.x - gridInfo.topLeft.x, gridH = gridInfo.bottomRight.y - gridInfo.topLeft.y;
                const cellW = gridW / gridInfo.cols, cellH = gridH / gridInfo.rows;
                const shadowGeo = new THREE.PlaneGeometry(cellW * 0.8, cellH * 0.8);
                const shadowMat = new THREE.MeshBasicMaterial({ color: 0x000000, transparent: true, opacity: 0.4 });
                for (let i = 1; i <= gridInfo.rows * gridInfo.cols; i++) {
                    const isShallow = shallowSquares.includes(i);
                    const {x, y} = getWorldCoordsFromGridKey(i);
                    const shadow = new THREE.Mesh(shadowGeo, shadowMat);
                    shadow.position.set(x, y, 1);
                    shadow.visible = false;
                    shadow.userData = { type: 'shipShadow', key: i, isShallow: isShallow };
                    scene.add(shadow);
                    shipPlacementShadows.push(shadow);
                }
                // Create a pool of temporary shadows for off-grid moves
                for (let i = 0; i < 8; i++) {
                    const shadow = new THREE.Mesh(shadowGeo, shadowMat);
                    shadow.visible = false;
                    scene.add(shadow);
                    tempShadowPool.push(shadow);
                }
            }

            function animateMove(object, targetPosition, onComplete) {
                animations.push({
                    object: object,
                    startPosition: object.position.clone(),
                    targetPosition: targetPosition,
                    alpha: 0,
                    duration: 0.5, // seconds
                    onComplete: onComplete
                });
            }

            // --- GAME ACTION FUNCTIONS ---
            function placeTideAt(shadow) {
                const tideToMove = initialTides.shift();
                const posKey = shadow.userData.key;
                const targetPosition = shadow.position.clone().setZ(25);

                animateMove(tideToMove, targetPosition, () => {
                    if (tidesOnBoard[posKey]) { 
                        tideToMove.position.x += 30; 
                        tidesOnBoard[posKey].push(tideToMove); 
                    } else { 
                        tidesOnBoard[posKey] = [tideToMove]; 
                    }
                    tideToMove.userData.locationKey = posKey;
                    placedTides.push(tideToMove);
                    tidesPlacedCount++;
                    advanceTurn();
                });
            }

            function placeShipAt(shadow) {
                const shipType = shipsPlacedCount % 2 === 0 ? 'corsairs' : 'galleons';
                const shipToMove = (shipType === 'corsairs') ? initialCorsairs.shift() : initialGalleons.shift();
                if (shipToMove) {
                    const targetPosition = shadow.position.clone().setZ(25);
                    animateMove(shipToMove, targetPosition, () => {
                        shipToMove.userData.locationKey = shadow.userData.key;
                        shipToMove.userData.lives = 2; // Initialize lives
                        shipToMove.userData.justDeployed = false; // Can move on first turn of play
                        if(shipType === 'corsairs') placedCorsairs.push(shipToMove); else placedGalleons.push(shipToMove);
                        shadow.visible = false;
                        shipsPlacedCount++;
                        advanceTurn();
                    });
                }
            }

            function moveTide(tideToMove, targetShadow) {
                const newLocKey = targetShadow.userData.key;
                const oldLocKey = tideToMove.userData.locationKey;
                if (tidesOnBoard[oldLocKey]) tidesOnBoard[oldLocKey] = tidesOnBoard[oldLocKey].filter(t => t !== tideToMove);
                
                const occupants = tidesOnBoard[newLocKey] ? tidesOnBoard[newLocKey].length : 0;
                const targetPosition = targetShadow.position.clone().add(new THREE.Vector3(occupants * 30, 0, 0)).setZ(25);

                animateMove(tideToMove, targetPosition, () => {
                    if (!tidesOnBoard[newLocKey]) tidesOnBoard[newLocKey] = [];
                    tidesOnBoard[newLocKey].push(tideToMove);
                    tideToMove.userData.locationKey = newLocKey;
                    tidePlacementShadows.forEach(s => { s.visible = false; delete s.userData.tideToMove; });
                    initiateShipMovePhase();
                });
            }
            
            function damageShip(ship) {
                if (ship.userData.sunk) return;

                ship.userData.lives--;
                const team = placedCorsairs.includes(ship) ? 'Corsairs' : 'Galleons';
                console.log(`${team}'s ship was hit! Lives remaining: ${ship.userData.lives}`);
                
                if (ship.userData.lives <= 0) {
                    ship.rotation.x = Math.PI; 
                    ship.rotation.z = 0;
                    ship.position.z = 10;
                    ship.userData.sunk = true;
                    console.log(`${team}'s ship has sunk!`);
                    checkWinCondition();
                } else {
                    ship.rotation.z += THREE.MathUtils.degToRad(50);
                }
            }

            function checkForAdjacentAttacks(attackingShip) {
                if (gameState === 'GAME_OVER') return;
                const attackerIsCorsair = placedCorsairs.includes(attackingShip);
                const enemyShips = attackerIsCorsair ? placedGalleons : placedCorsairs;
                const attackerKey = attackingShip.userData.locationKey;

                const keyAbove = attackerKey - gridInfo.cols;
                const keyBelow = attackerKey + gridInfo.cols;

                enemyShips.forEach(enemy => {
                    if (!enemy.userData.sunk && (enemy.userData.locationKey === keyAbove || enemy.userData.locationKey === keyBelow)) {
                        console.log("Adjacent enemy found! Attacking.");
                        damageShip(enemy);
                    }
                });
            }
            
            function deployReinforcement(reinforcementInfo) {
                const { newShip, targetShadow, isCorsair, onComplete } = reinforcementInfo;
                const targetPosition = targetShadow.position.clone().setZ(25);

                // Immediately move the ship, do not animate, to prevent freezing bug.
                newShip.position.copy(targetPosition); 

                try {
                    newShip.userData.locationKey = targetShadow.userData.key;
                    newShip.userData.lives = 2;
                    newShip.userData.justDeployed = true; // Ship cannot move this turn
                    if (isCorsair) {
                        placedCorsairs.push(newShip);
                    } else {
                        placedGalleons.push(newShip);
                    }
                    console.log("New ship placed.");
                } catch (e) {
                    console.error("Error in deployment logic:", e);
                } finally {
                    // Immediately call the completion callback to continue the game.
                    onComplete();
                }
            }

            function handleReinforcementChoice(didDeploy) {
                return () => {
                    reinforcementUI.style.display = 'none';
                    playUI.style.display = 'block';

                    if (didDeploy && pendingReinforcement) {
                        deployReinforcement(pendingReinforcement);
                    } else if (pendingReinforcement) {
                        const shipToReturn = pendingReinforcement.newShip;
                        const sparePool = pendingReinforcement.isCorsair ? initialCorsairs : initialGalleons;
                        sparePool.unshift(shipToReturn); 

                        pendingReinforcement.onComplete();
                    }
                    pendingReinforcement = null;
                };
            }

            function checkForReinforcements(movedShip, onComplete) {
                if (gameState === 'GAME_OVER') { onComplete(); return; }

                const landingKey = movedShip.userData.locationKey;
                const targetKey = portSquarePairs[landingKey];
                let canDeploy = (targetKey !== undefined);

                const isCorsair = placedCorsairs.includes(movedShip);
                const spareShips = isCorsair ? initialCorsairs : initialGalleons;
                
                if (canDeploy && spareShips.length === 0) canDeploy = false;

                if (canDeploy) {
                    const isTargetOccupied = [...placedCorsairs, ...placedGalleons].some(ship => ship.userData.locationKey === targetKey);
                    if (isTargetOccupied) canDeploy = false;
                }

                const targetShadow = canDeploy ? shipPlacementShadows.find(s => s.userData.key === targetKey) : null;
                if (canDeploy && !targetShadow) {
                    console.error(`Could not find a shadow for port key ${targetKey}.`);
                    canDeploy = false;
                }

                if (canDeploy) {
                    const newShip = spareShips.shift();
                    const reinforcementInfo = { newShip, targetShadow, isCorsair, onComplete };
                    if (isPlayerTurn) {
                        pendingReinforcement = reinforcementInfo;
                        playUI.style.display = 'none';
                        reinforcementUI.style.display = 'block';
                    } else {
                        // AI always deploys.
                        deployReinforcement(reinforcementInfo);
                    }
                } else {
                    onComplete();
                }
            }

            function handleShipMove(shipToMove, targetShadow) {
                if (targetShadow.userData.isDanger) {
                    damageShip(shipToMove);
                    shipPlacementShadows.forEach(s => { s.visible = false; });
                    tempShadowPool.forEach(s => { s.visible = false; });
                    if (gameState !== 'GAME_OVER') {
                        shipsToMoveThisTurn = shipsToMoveThisTurn.filter(s => s !== shipToMove);
                        selectedShip = null;
                        processNextShipMove();
                    }
                } else {
                    const targetPosition = targetShadow.position.clone().setZ(25);
                    animateMove(shipToMove, targetPosition, () => {
                        shipToMove.userData.locationKey = targetShadow.userData.key;
                        shipPlacementShadows.forEach(s => { s.visible = false; });
                        tempShadowPool.forEach(s => { s.visible = false; });
                        checkForAdjacentAttacks(shipToMove);
                        if (gameState !== 'GAME_OVER') {
                            shipsToMoveThisTurn = shipsToMoveThisTurn.filter(s => s !== shipToMove);
                            selectedShip = null;
                            checkForReinforcements(shipToMove, processNextShipMove);
                        }
                    });
                }
            }

            // --- AI ACTIONS ---
            function aiPlaceTide() {
                const available = tidePlacementShadows.filter(s => s.visible);
                if (available.length > 0) placeTideAt(available[Math.floor(Math.random() * available.length)]);
            }
            function aiPlaceShip() {
                const available = shipPlacementShadows.filter(s => s.userData.isShallow && s.visible);
                if (available.length > 0) placeShipAt(available[Math.floor(Math.random() * available.length)]);
            }
            function aiMoveTide() {
                 const availableMoves = [];
                 placedTides.forEach(tide => {
                    const nextKey = tideSequence[(tideSequence.indexOf(tide.userData.locationKey) + 1) % tideSequence.length];
                    const nextShadow = tidePlacementShadows.find(s => s.userData.key === nextKey);
                    if (nextShadow) {
                        availableMoves.push({ tide: tide, shadow: nextShadow });
                    }
                });
                if (availableMoves.length > 0) {
                    const chosenMove = availableMoves[Math.floor(Math.random() * availableMoves.length)];
                    moveTide(chosenMove.tide, chosenMove.shadow);
                }
            }
            function aiMoveShip(shipToMove, validMoves) {
                if (validMoves.length > 0) {
                    const safeMoves = validMoves.filter(m => !m.isDanger);
                    const chosenMove = (safeMoves.length > 0) ? 
                        safeMoves[Math.floor(Math.random() * safeMoves.length)] :
                        validMoves[Math.floor(Math.random() * validMoves.length)];

                    let targetShadow;
                    const permanentShadow = shipPlacementShadows.find(s => s.userData.key === chosenMove.key);

                    if (chosenMove.isOnGrid && permanentShadow) {
                         targetShadow = {
                            position: permanentShadow.position.clone(),
                            userData: chosenMove 
                        };
                    } else { // Off-grid move
                        const {x, y} = getWorldCoordsFromGridRowCol(chosenMove.row, chosenMove.col);
                        targetShadow = { position: new THREE.Vector3(x, y, 1), userData: chosenMove };
                    }
                    
                    if (targetShadow) {
                        handleShipMove(shipToMove, targetShadow);
                    } else {
                        console.log("AI couldn't find a target shadow. Skipping this ship.");
                        shipsToMoveThisTurn.shift();
                        processNextShipMove();
                    }
                } else {
                    console.log("AI has no valid moves for this ship. Skipping.");
                    shipsToMoveThisTurn.shift();
                    processNextShipMove();
                }
            }
			
            function onMouseDown(event) {
                isDragging = false;
                startMousePos.set(event.clientX, event.clientY);
            }

            function onMouseMove(event) {
                if (isDragging) return; // No need to check if we already know it's a drag
                const currentMousePos = new THREE.Vector2(event.clientX, event.clientY);
                if (startMousePos.distanceTo(currentMousePos) > dragThreshold) {
                    isDragging = true;
                }
            }

            function onMouseUp(event) {
                if (isDragging) {
                    // It was a drag, OrbitControls handled it. Do nothing.
                    return;
                }
                
                // It was a click, run the selection logic.
                if (!isPlayerTurn || animations.length > 0 || pendingReinforcement || gameState === 'GAME_OVER') return;
                mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
                raycaster.setFromCamera(mouse, camera);
                
                const allShipShadows = [...shipPlacementShadows, ...tempShadowPool];
                const getIntersect = (shadows) => {
                    const intersects = raycaster.intersectObjects(shadows);
                    return (intersects.length > 0 && intersects[0].object.visible) ? intersects[0].object : null;
                };

                if (gameState === 'TIDE_PLACEMENT') {
                    const shadow = getIntersect(tidePlacementShadows);
                    if (shadow) placeTideAt(shadow);
                } else if (gameState === 'SHIP_PLACEMENT') {
                    const shadow = getIntersect(shipPlacementShadows);
                    if (shadow) placeShipAt(shadow);
                } else if (gameState === 'PLAY') {
                    if (turnPhase === 'MOVE_TIDE') {
                        const shadow = getIntersect(tidePlacementShadows);
                        if (shadow) moveTide(shadow.userData.tideToMove, shadow);
                    } else if (turnPhase === 'SELECT_SHIP') {
                        const intersects = raycaster.intersectObjects(shipsToMoveThisTurn);
                        if (intersects.length > 0) {
                            showMovesForShip(intersects[0].object);
                        }
                    } else if (turnPhase === 'MOVE_SELECTED_SHIP') {
                        const shadow = getIntersect(allShipShadows);
                        if (shadow) {
                           if(selectedShip) handleShipMove(selectedShip, shadow);
                        }
                    }
                }
            }

            // --- HELPER & STATE FUNCTIONS ---
            function getWorldCoordsFromGridKey(key) {
                const col = (key - 1) % gridInfo.cols;
                const row = Math.floor((key - 1) / gridInfo.cols);
                return getWorldCoordsFromGridRowCol(row, col);
            }

            function getWorldCoordsFromGridRowCol(row, col) {
                const gridW = gridInfo.bottomRight.x - gridInfo.topLeft.x;
                const gridH = gridInfo.bottomRight.y - gridInfo.topLeft.y;
                const cellW = gridW / gridInfo.cols;
                const cellH = gridH / gridInfo.rows;
                const px = gridInfo.topLeft.x + (col * cellW) + (cellW / 2);
                const py = gridInfo.topLeft.y + (row * cellH) + (cellH / 2);
                return { x: px - (boardImageWidth / 2), y: -py + (boardImageHeight / 2) };
            }
            
            function calculateShipMoves(ship) {
                const currentSquare = ship.userData.locationKey;
                const currentCol = (currentSquare - 1) % gridInfo.cols;
                const currentRow = Math.floor((currentSquare - 1) / gridInfo.cols);
                const allShips = [...placedCorsairs, ...placedGalleons];
                const occupiedSquares = allShips.map(s => s.userData.locationKey);

                const tideLocations = placedTides.map(t => t.userData.locationKey);
                let moveDestinations = new Map();
                
                tideLocations.forEach(locKey => {
                    const vec = moveVectors[locKey];
                    const newRow = currentRow + vec.r;
                    const newCol = currentCol + vec.c;
                    const newSquare = newRow * gridInfo.cols + newCol + 1;
                    
                    if (!moveDestinations.has(newSquare)) {
                        const isOffGrid = newRow < 0 || newRow >= gridInfo.rows || newCol < 0 || newCol >= gridInfo.cols;
                        const isCorner = !isOffGrid && gridInfo.cornerSquares.includes(newSquare);
                        const isOccupied = !isOffGrid && occupiedSquares.includes(newSquare);
                        
                        moveDestinations.set(newSquare, {
                            key: newSquare,
                            row: newRow,
                            col: newCol,
                            isDanger: isOffGrid || isCorner || isOccupied,
                            isOnGrid: !isOffGrid
                        });
                    }
                });
                return Array.from(moveDestinations.values());
            }

            // --- GAME FLOW CONTROL ---
            function checkWinCondition() {
                const playerShips = (playerTeam === 'corsairs') ? placedCorsairs : placedGalleons;
                const aiShips = (aiTeam === 'corsairs') ? placedCorsairs : placedGalleons;

                const allPlayerShipsSunk = playerShips.length > 0 && playerShips.every(s => s.userData.sunk);
                const allAiShipsSunk = aiShips.length > 0 && aiShips.every(s => s.userData.sunk);

                if (allPlayerShipsSunk) {
                    gameState = 'GAME_OVER';
                    gamePrompt.textContent = 'Adella wins!';
                    return true;
                }
                if (allAiShipsSunk) {
                    gameState = 'GAME_over';
                    gamePrompt.textContent = "You've won!";
                    return true;
                }
                return false;
            }

            function initiateTideMovePhase() {
                turnPhase = 'MOVE_TIDE';
                placedTides.forEach(tide => {
                    const nextKey = tideSequence[(tideSequence.indexOf(tide.userData.locationKey) + 1) % tideSequence.length];
                    const nextShadow = tidePlacementShadows.find(s => s.userData.key === nextKey);
                    if (nextShadow) {
                        nextShadow.visible = true;
                        nextShadow.userData.tideToMove = tide;
                    }
                });

                if (isPlayerTurn) {
                    gamePrompt.textContent = 'Move a tide.';
                } else {
                    gamePrompt.textContent = 'Adella is thinking...';
                    setTimeout(aiMoveTide, 1500);
                }
            }

            function showMovesForShip(ship) {
                selectedShip = ship;
                shipPlacementShadows.forEach(s => s.visible = false);
                tempShadowPool.forEach(s => s.visible = false);

                const moves = calculateShipMoves(ship);
                if (moves.length === 0) {
                    gamePrompt.textContent = 'No moves for this ship!';
                    setTimeout(() => {
                        shipsToMoveThisTurn = shipsToMoveThisTurn.filter(s => s !== ship);
                        processNextShipMove();
                    }, 1500);
                    return;
                }
                
                turnPhase = 'MOVE_SELECTED_SHIP';
                gamePrompt.textContent = 'Select a shadow.';

                let tempShadowIdx = 0;
                moves.forEach(move => {
                    let shadow;
                    if (move.isOnGrid) {
                        shadow = shipPlacementShadows.find(s => s.userData.key === move.key);
                    } else {
                        if (tempShadowIdx < tempShadowPool.length) {
                            shadow = tempShadowPool[tempShadowIdx++];
                            const { x, y } = getWorldCoordsFromGridRowCol(move.row, move.col);
                            shadow.position.set(x, y, 1);
                            shadow.userData = move;
                        }
                    }
                    if (shadow) {
                        shadow.visible = true;
                        shadow.userData.isDanger = move.isDanger;
                    }
                });
            }

            function processNextShipMove() {
                shipPlacementShadows.forEach(s => s.visible = false);
                tempShadowPool.forEach(s => s.visible = false);
                selectedShip = null;

                if (shipsToMoveThisTurn.length === 0) {
                    console.log("All ships have moved. Advancing turn.");
                    advanceTurn();
                    return;
                }

                if (isPlayerTurn) {
                    if (shipsToMoveThisTurn.length > 1) {
                        turnPhase = 'SELECT_SHIP';
                        gamePrompt.textContent = 'Select a ship, then a shadow.';
                    } else { // Auto-select the last ship
                        showMovesForShip(shipsToMoveThisTurn[0]);
                    }
                } else { // AI's turn
                    const shipToMove = shipsToMoveThisTurn[0]; // AI moves in sequence
                    const moves = calculateShipMoves(shipToMove);
                    const movedCount = totalShipsToMoveThisTurn - shipsToMoveThisTurn.length;
                    gamePrompt.textContent = `Adella is moving her ship (${movedCount + 1} of ${totalShipsToMoveThisTurn})`;
                    if (moves.length === 0) {
                        console.log("AI has no moves, skipping ship.");
                        shipsToMoveThisTurn.shift();
                        setTimeout(processNextShipMove, 100);
                        return;
                    }
                    setTimeout(() => aiMoveShip(shipToMove, moves), 1500);
                }
            }

            function initiateShipMovePhase() {
                const playerShips = isPlayerTurn ?
                    (playerTeam === 'corsairs' ? placedCorsairs : placedGalleons) :
                    (aiTeam === 'corsairs' ? placedCorsairs : placedGalleons);

                shipsToMoveThisTurn = playerShips.filter(ship => !ship.userData.sunk && !ship.userData.justDeployed);
                totalShipsToMoveThisTurn = shipsToMoveThisTurn.length;
                
                if (shipsToMoveThisTurn.length === 0) {
                    gamePrompt.textContent = 'No ships to move!';
                    setTimeout(advanceTurn, 1500);
                    return;
                }

                processNextShipMove();
            }

            function advanceTurn() {
                if (gameState === 'GAME_OVER') return;

                if (gameState === 'TIDE_PLACEMENT') {
                    isPlayerTurn = !isPlayerTurn;
                    if (tidesPlacedCount < 3) {
                        const turnText = tidesPlacedCount === 1 ? 'second' : 'third';
                        gamePrompt.textContent = isPlayerTurn ? `Place ${turnText} tide.` : 'Adella is thinking...';
                        if (!isPlayerTurn) setTimeout(aiPlaceTide, 1500);
                    } else { 
                        instructionText.style.display = 'none';
                        instructionText2.style.display = 'block';
                        gameState = 'SHIP_PLACEMENT';
                        tidePlacementShadows.forEach(s => s.visible = false);
                        for (const key in portLabels) {
                            if (portLabels[key]) portLabels[key].style.display = 'block';
                        }
                        isPlayerTurn = (playerTeam === 'corsairs'); 
                        gamePrompt.textContent = isPlayerTurn ? 'Set ship on a shallow.' : 'Adella is thinking...';
                        shipPlacementShadows.forEach(s => { if(s.userData.isShallow) s.visible = true; });
                        if (!isPlayerTurn) setTimeout(aiPlaceShip, 1500);
                    }
                } else if (gameState === 'SHIP_PLACEMENT') {
                     isPlayerTurn = !isPlayerTurn;
                    if (shipsPlacedCount < 2) {
                        gamePrompt.textContent = isPlayerTurn ? 'Set ship on a shallow.' : 'Adella is thinking...';
                        if (!isPlayerTurn) setTimeout(aiPlaceShip, 1500);
                    } else {
                        instructionText2.style.display = 'none';
                        for (const key in portLabels) {
                            if (portLabels[key]) portLabels[key].style.display = 'none';
                        }
                        gameState = 'PLAY';
                        gamePrompt.textContent = 'Board is set.';
                        shipPlacementShadows.forEach(s => s.visible = false);
                        isPlayerTurn = (playerTeam === 'corsairs');
                        setTimeout(initiateTideMovePhase, 1500);
                    }
                } else if (gameState === 'PLAY') {
                    isPlayerTurn = !isPlayerTurn;

                    const shipsToActivate = isPlayerTurn ?
                        (playerTeam === 'corsairs' ? placedCorsairs : placedGalleons) :
                        (aiTeam === 'corsairs' ? placedCorsairs : placedGalleons);
                    
                    shipsToActivate.forEach(ship => {
                        if (ship.userData.justDeployed) {
                            console.log("Activating a newly deployed ship for next turn.");
                            ship.userData.justDeployed = false;
                        }
                    });

                    setTimeout(initiateTideMovePhase, 1000);
                }
            }

            function updatePortLabelPositions() {
                if (gameState !== 'SHIP_PLACEMENT') return;

                for (const key in portLabelWorldPositions) {
                    const worldPos = portLabelWorldPositions[key];
                    const screenPos = worldPos.clone().project(camera);

                    const x = (screenPos.x * .5 + .5) * renderer.domElement.clientWidth;
                    const y = (screenPos.y * -.5 + .5) * renderer.domElement.clientHeight;

                    const label = portLabels[key];
                    if (label) {
                        label.style.left = `${x}px`;
                        label.style.top = `${y}px`;
                    }
                }
            }

            window.addEventListener('mousedown', onMouseDown);
            window.addEventListener('mousemove', onMouseMove);
            window.addEventListener('mouseup', onMouseUp);

            function fitCameraToBoard(imageWidth, imageHeight) {
                resizeRendererToDisplaySize(renderer);
                const boardAspect = imageWidth / imageHeight;
                const cameraAspect = camera.aspect;
                const vFOV = THREE.MathUtils.degToRad(camera.fov);
                let distance;
                if (boardAspect > cameraAspect) {
                    const hFOV = 2 * Math.atan(Math.tan(vFOV / 2) * cameraAspect);
                    distance = (imageWidth / 2) / Math.tan(hFOV / 2);
                } else {
                    distance = (imageHeight / 2) / Math.tan(vFOV / 2);
                }
                camera.position.z = distance * 1.05;
                controls.target.set(0, 0, 0);
                controls.update();
            }

			function resizeRendererToDisplaySize(renderer) {
				const canvas = renderer.domElement;
				const width = canvas.clientWidth, height = canvas.clientHeight;
				if (canvas.width !== width || canvas.height !== height) {
					renderer.setSize(width, height, false);
					camera.aspect = width / height;
					camera.updateProjectionMatrix();
				}
			}

			function animate() {
				requestAnimationFrame(animate);

                const delta = 0.016; // Assume ~60fps
                animations = animations.filter(anim => {
                    anim.alpha += delta / anim.duration;
                    if(anim.alpha >= 1) {
                        anim.object.position.copy(anim.targetPosition);
                        if(anim.onComplete) anim.onComplete();
                        return false; // Remove from list
                    }
                    anim.object.position.lerpVectors(anim.startPosition, anim.targetPosition, anim.alpha);
                    return true; // Keep in list
                });

                updatePortLabelPositions();

				resizeRendererToDisplaySize(renderer);
				controls.update();
				renderer.render(scene, camera);
			}
			animate();
		</script>
	</body>
</html>

